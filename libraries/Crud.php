<?
class Crud_Core extends Controller {
	public $columns;
	public $relationships;
	public $errors;
	
	public $base_config;
	public $orm_name;
	
	// allow display customization
	public $edit_template = 'form';
	public $view_template = 'view';
	public $fields_template = 'fields';	// template to use for field generation
	public $form_class = 'hform';
	public $form_action = '';			// auto set in the constructor
	public $form_name = '';
	
	protected $relationshipIdentifier = '[]';
	public $form;
	
	function __construct($data_holder) {
		parent::__construct();
		
		// not sure if these are being copied or referenced
		// if you want to overide any of the values in base_config in a super-super class (the class subclassing CMS) this may cause problems
		
		// Note that CMS uses this object as a sort of core module
		// It passes off the column names & relationships and that is about it, no more column managment is done by CMS
		
		$this->columns = $data_holder->columns;
		$this->relationships = isset($data_holder->relationships) ? $data_holder->relationships : array(); // for direct (non CMS) use Crud, we might not always need relationships
		$this->errors = array();
		
		$this->orm_name = $data_holder->orm_name;
		$this->base_config = & $data_holder->base_config;	// there is no need to copy the array, referencing it allows more flexibility
		
		// note that base_config should contain the following:
		//	title or submit_title (note that title is auto generated by the CMS using the orm name and titlize)
		//		
				
		// add relationships to the column list, we have to generate content functions & attempt to guess default values
		foreach($this->relationships as $name => $relationshipInfo) {
			// the tricky label code strips out the commonality between a category listing & the relationship, ex:
			//	news_item_categories
			//	news_items
			//	resulting nlabel: Categories
			
			// note that the orm_name will be the singular of the plural db name
			$simpleTitle = starts_with($this->orm_name, $name) ? inflector::titlize(substr($name, strlen($this->orm_name))) : inflector::titlize($name);
			
			// default type to multi (many-to-many)
			
			if(empty($relationshipInfo['type'])) $relationshipInfo['type'] = 'multi';
			
			if($relationshipInfo['type'] == 'one') {
				// for one-to-one we don't use a pivot table
				// convention is to use: singular_table_id
				
				$this->columns[$name.'_id'] = array(
					'label' => $simpleTitle,
					'type' => 'select',
					'values' => ORM::factory(inflector::singular($name))->select_list($relationshipInfo['display_key'], 'id')
				);
		} else { // many
				// for the view
			
				$this->columns[$name] = array(
					'restrict' => 'view',
					'label' => $simpleTitle,
					'content' => create_function('$arg', '$str = ""; foreach($arg->'.$name.' as $rel) {$str .= $rel->'.$relationshipInfo['display_key'].'."<br />";} return $str;')			
				);
						
				// for the edit field
			
				$this->columns[$name.$this->relationshipIdentifier] = array_merge($relationshipInfo, array(
					'restrict' => 'edit',
					'label' => $simpleTitle,
					'type' => 'mselect',
					'values' => ORM::factory(inflector::singular($name))->select_list($relationshipInfo['display_key'], 'id')
				));
			}
		}
		
		// normalize the column array
		// 	default type: text
		//	default restrict: none
		//	default content: text
		
		foreach($this->columns as $name => $columnInfo) {
			if(!isset($columnInfo['type'])) {
				$this->columns[$name]['type'] = 'text';
			}
			
			if(!isset($columnInfo['restrict'])) {
				$this->columns[$name]['restrict'] = 'none';
			}
			
			if(!isset($columnInfo['content'])) {
				$this->columns[$name]['content'] = 'text';
			}
			
			if(!isset($columnInfo['format'])) {
				$this->columns[$name]['format'] = '';
			}
		}
		
		// this works in most CMS situations (editing controller/edit/id, the id is then passed to edit())
		// however in form generation situations we may want to define a custom action
		
		$this->form_action = Kohana::config('admin.base').url::current();
	}
	
	public function view() {
		// filter out edit only columns
		$columnNames = array();
		
		foreach($this->columns as $name => $columnInfo)
			if(!isset($columnInfo['restrict']) || $columnInfo['restrict'] != 'edit')
				$columnNames[$name] = $columnInfo;
		
		return $columnNames;
	}
	
	public function edit($id = null) {
		// there are three 'modes' of this function: view, edit, and create
		// if we aren't editing or creating we are viewing
		// When you are in the process of editing a script you are NOT editing it.
		
		$page = ORM::factory($this->orm_name, (int) $id);
		$columnNames = array();

		if(!$page->loaded) {// creating / viewing
			$mode = "create";
			$page = ORM::factory($this->orm_name);
		} else {// editing
			$mode = "edit";
			$page = ORM::factory($this->orm_name, (int) $id);
		}
				
		$form = Formo::factory($this->form_name ? $this->form_name : $this->orm_name)
			->set('action', $this->form_action)
			->set('_class', $this->form_class);
		
		// looks like formo strtolowers the $columnName
		// this means that your dbs must use field_name instead of FieldName or you will get an undefined index error
		
		foreach($this->columns as $columnName => $columnInfo) {
			if($columnInfo['restrict'] == "view") continue;
			else $columnNames[$columnName] = $columnInfo;
			
			if($columnInfo['type'] == 'custom') continue;
			
			$options = $this->_getFormoOptions($columnName, $columnInfo, $page);
			
			if($columnInfo['type'] == 'checkbox') {
				$form->add_group($columnName.'[]', $options['values']);
				
				// for some reason we have to manually assign label... bug?
				// this label is displayed in the error 
				$form->$columnName->label = $options['label'];
			} else {
				$form->add($columnInfo['type'], $columnName, $options);
			}
		}

		if($form->validate() && count($this->errors) == 0) {
			// this adds the relationship identifier ([]) to the relationship names and merges the list with the column name list
			// because the relationship_name is copied over to $columnNames as relationship_name[] during initialization
			// we have to do add the suffix and then merge the columns since these columns do not exist in the actual table schema
			
			$relationshipCopyList = array_fill_keys(array_add_value_suffix(array_keys($this->relationships), $this->relationshipIdentifier), 'relationship');
			
			foreach(array_merge($relationshipCopyList, $page->table_columns) as $columnName => $columnInfo) {
				// Be nice and don't cause errors trying to copy over data to columns that don't exist
				if(!isset($columnNames[$columnName])) continue;

				if($columnNames[$columnName]['type'] == 'file') {
					// use uploaded file name rather than the original file name
					
					if(isset($form->$columnName->data['file_name'])) { // this is for when the file name isn't required
						$page->$columnName = $form->$columnName->data['file_name'];
					} else {
						Kohana::log('debug', 'File data not submitted');
					}
				} else if(substr($columnName, -2) == $this->relationshipIdentifier) {
					// multiple values isn't really natively supported in formo
					// we have to go directly into the post data and retrieve the list
					
					$normalizedRelationshipName = substr($columnName, 0, -2);
					$post = input::instance()->post();
					$page->$normalizedRelationshipName = $post[$normalizedRelationshipName];
				} else {
					$page->$columnName = $form->$columnName->value;
				}
			}
			
			// if the form is valid, we return the $mode and the $page content
			// note that for the data to be saved $page->save() must be called afterward
			
			// you can use Crud as an ad hoc form generator
			// simple set your form content to $result['data] & specify a custom $edit_template
			
			return array('mode' => $mode, 'data' => $page);
		}
		
		$compiledForm = $form->get(TRUE);
		
		$this->form = $form;

		return array(
			'mode' => 'view',
			'data' => View::factory($this->edit_template, array_merge($this->base_config, array(
				'form' => $compiledForm,	// for the open/close form tags
				'fields' => View::factory($this->fields_template, array(
					'columns' => $columnNames,
					'form' => $compiledForm
				)),
				'errors' => array_merge($form->get_errors(), $this->errors),
				'submit_title' => empty($this->base_config['submit_title']) ? ($mode == "edit" ? 'Save Changes' : 'Create New '.$this->base_config['title']) : $this->base_config['submit_title']	// you overide this title by accessing $this->template->content->submit_title in the subclass
			)))
		);
    }
	
	public function delete($id = null) {
		$post = ORM::factory($this->orm_name, (int) $id);

		if(!$post->loaded) return false;
		
		// maybe do some more error checking here
		$post->delete();
		
		return true;
	}
	
	// this should be moved into another class... but for now this will do
	
	public function generate_email_message() {
		$post = $this->input->post();
		$message = '';
		
		foreach($this->columns as $columnName => $columnInfo) {
			// we skip custom (aka headers / title blocks) and 'display only' elements
			if($columnInfo['type'] == 'custom') continue;
			if($columnInfo['restrict'] == 'view') continue;
			
			$message .= (empty($columnInfo['label']) ? inflector::titlize($columnName) : $columnInfo['label']).": ";
			
			if($columnInfo['type'] == 'checkbox') {
				// if we are processing a checkbox they could select multiple options
				// formo returns a list of the keys in the values list, we have to grab the label values associated with each key
				
				$convertedList = array();
				foreach($post[$columnName] as $key) {
					// we strip tags here b/c it is possible to embed sub fields within the text of a checkbox label
					$convertedList[] = strip_tags($this->columns[$columnName]['values'][$key]);
				}
				
				$message.= implode(', ', $convertedList)."\n";
			} else {
				$message .= $post[$columnName]."\n";
			}
		}
		
		return $message;
	}
	
	// private functions
	
	protected function _getFormoOptions($columnName, $columnData, $page) {
		// values is an array of options to be sent to formo->add
		$values = array('required' => 1);
		
		// the $page should have precedent over predefined constants ONLY if it was loaded
		
		if($page->loaded && isset($page->$columnName)) {
			$values['value'] = $page->$columnName;
		} else if(isset($columnData['value'])) {
			$values['value'] = $columnData['value'];
		}
		
		if($accessField = $this->isRelationshipField($columnName)) {
			// then we are dealing with a relationship

			if($columnData['type'] == 'mselect') {
				// get a list of IDs
				$primaryKey = $page->primary_key;
				$selectedList = iterator_to_array($page->$accessField);
				$idList = array();
				
				foreach($selectedList as $relatedObject) {
					$idList[] = $relatedObject->$primaryKey;
				}

				$values['selected_values'] = $idList;
			} else if($columnData['type'] == 'select') {
				
			}
		}
		
		// this is a list of fields to be copied over as attributes (unless they are 'special' fields) of the HTML element
		$copyList = array('style', 'class', 'required', 'label', 'multiple', 'allowed_types', 'max_size', 'upload_path', 'rule', 'error_msg');
		
		foreach($copyList as $attrib) {
			if(isset($columnData[$attrib])) {
				$values[$attrib] = $columnData[$attrib];
			}
		}
		
		// if the required field is set auto set class='required' if not explicitly defined
		if($values['required'] && !isset($values['class'])) {
			$values['class'] = 'required';
		}
		
		// make the labels for the form fields look nice
		// < 3 => probably an abbreviation
		if(!isset($values['label'])) {
			$values['label'] = inflector::titlize($columnName);
		}
		
		if(strrpos($columnData['type'], 'select') !== FALSE || $columnData['type'] == 'checkbox') {
			// check to make sure values is an array, if not it will cause issues in select library
			if(!is_array($columnData['values'])) Kohana::log('error', 'CRUD form generator found select values error for field '.$columnName);
			
			$values['values'] = $columnData['values'];
		}
		
		return $values;
	}
	
	private function isRelationshipField($fieldName) {
		if(substr($fieldName, -2) == $this->relationshipIdentifier) {
			return substr($fieldName, 0, -2);
		} else {
			return FALSE;
		}
	}
}

?>