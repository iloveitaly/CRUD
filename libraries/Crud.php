<?
class Crud_Core extends FormGen_Core {
	public $relationships;
	public $errors;
	
	public $base_config;
	public $orm_name;
	
	// allow display customization
	public $edit_template = 'form';
	public $view_template = 'view';
	public $fields_template = 'fields';	// template to use for field generation
	public $form_class = 'hform';
	public $form_action = '';			// auto set in the constructor, specify if using in a non CMS solution
	public $form_name = '';				// if form_name isn't set then the orn_name is used for the <form name>
	
	public $form;
	
	function __construct($data_holder) {
		parent::__construct();
		
		// not sure if these are being copied or referenced
		// if you want to overide any of the values in base_config in a super-super class (the class subclassing CMS) this may cause problems
		
		// Note that CMS uses this object as a sort of core module
		// It passes off the column names & relationships and that is about it, no more column managment is done by CMS
		
		$this->columns = $data_holder->columns;
		$this->relationships = isset($data_holder->relationships) ? $data_holder->relationships : array(); // for direct (non CMS) use Crud, we might not always need relationships
		$this->errors = array();
		
		$this->orm_name = $data_holder->orm_name;
		$this->base_config = & $data_holder->base_config;	// there is no need to copy the array, referencing it allows more flexibility
		
		// note that base_config should contain the following:
		//	title or submit_title (note that title is auto generated by the CMS using the orm name and titlize)
		//		
				
		// add relationships to the column list, we have to generate content functions & attempt to guess default values
		// note that relationships != checkbox / radio groups. The relationship functionality was built for database relationships
		
		foreach($this->relationships as $name => $relationshipInfo) {
			// the tricky label code strips out the commonality between a category listing & the relationship, ex:
			//	news_item_categories
			//	news_items
			//	resulting nlabel: Categories
			
			// note that the orm_name will be the singular of the plural db name
			$simpleTitle = starts_with($this->orm_name, $name) ? inflector::titlize(substr($name, strlen($this->orm_name))) : inflector::titlize($name);
			
			// default type to multi (many-to-many)
			
			if(empty($relationshipInfo['type'])) $relationshipInfo['type'] = 'multi';
			
			if($relationshipInfo['type'] == 'one') {
				// for one-to-one we don't use a pivot table
				// convention is to use: singular_table_id
				
				$this->columns[$name.'_id'] = array(
					'label' => $simpleTitle,
					'type' => 'select',
					'values' => ORM::factory(inflector::singular($name))->select_list($relationshipInfo['display_key'], 'id')
				);
		} else { // many
				// for the view
			
				$this->columns[$name] = array(
					'restrict' => 'view',
					'label' => $simpleTitle,
					'content' => create_function('$arg', '$str = ""; foreach($arg->'.$name.' as $rel) {$str .= $rel->'.$relationshipInfo['display_key'].'."<br />";} return $str;')			
				);
						
				// for the edit field
			
				$this->columns[$name.$this->relationshipIdentifier] = array_merge($relationshipInfo, array(
					'restrict' => 'edit',
					'label' => $simpleTitle,
					'type' => 'mselect',
					'values' => ORM::factory(inflector::singular($name))->select_list($relationshipInfo['display_key'], 'id')
				));
			}
		}
		
		// normalize the column array
		// 	default type: text
		//	default restrict: none
		//	default content: text
		
		foreach($this->columns as $name => $columnInfo) {
			if(!isset($columnInfo['type'])) {
				$this->columns[$name]['type'] = 'text';
			}
			
			if(!isset($columnInfo['restrict'])) {
				$this->columns[$name]['restrict'] = 'none';
			}
			
			if(!isset($columnInfo['content'])) {
				$this->columns[$name]['content'] = 'text';
			}
			
			if(!isset($columnInfo['format'])) {
				$this->columns[$name]['format'] = '';
			}
		}
		
		// this works in most CMS situations (editing controller/edit/id, the id is then passed to edit())
		// however in form generation situations we may want to define a custom action
		
		$this->form_action = Kohana::config('admin.base').url::current();
	}
	
	public function view() {
		// filter out edit only columns
		$columnNames = array();
		
		foreach($this->columns as $name => $columnInfo)
			if(!isset($columnInfo['restrict']) || $columnInfo['restrict'] != 'edit')
				$columnNames[$name] = $columnInfo;
		
		return $columnNames;
	}
	
	public function edit($id = null) {
		// there are three 'modes' of this function: view, edit, and create
		// if we aren't editing or creating we are viewing
		// When you are in the process of editing a script you are NOT editing it.
		
		$page = ORM::factory($this->orm_name, (int) $id);
		$columnNames = array();

		if(!$page->loaded) {// creating / viewing
			$mode = "create";
			$page = ORM::factory($this->orm_name);
		} else {// editing
			$mode = "edit";
			$page = ORM::factory($this->orm_name, (int) $id);
		}
				
		$form = Formo::factory($this->form_name ? $this->form_name : $this->orm_name)
			->set('action', $this->form_action)
			->set('_class', $this->form_class);
		
		// looks like formo strtolowers the $columnName
		// this means that your dbs must use field_name instead of FieldName or you will get an undefined index error
		
		/*
			There are a couple custom types:
				
				'custom' - a header or some other custom HTML, this is a special case in the fields.php view.
				Note that custom fields ARE not auto included in email generation or other cases
				
				'view' - used mainly in the CRUD use case. This is for generating a column which only displays when viewing all the data
		*/
		
		foreach($this->columns as $columnName => $columnInfo) {
			if($columnInfo['restrict'] == "view") continue;
			
			$columnNames[$columnName] = $columnInfo;
			
			if($columnInfo['type'] == 'custom') continue;
			
			$options = $this->_getOptions($columnName, $columnInfo, $page);
			
			if($columnInfo['type'] == 'checkbox') {
				$form->add_group($columnName.$this->relationshipIdentifier, $options['values']);
				
				// for some reason we have to manually assign label... bug?
				// this label is displayed in the error 
				$form->$columnName->label = $options['label'];
			} else {
				$form->add($columnInfo['type'], $columnName, $options);
			}
		}

		if($form->validate() && count($this->errors) == 0) {
			// this adds the relationship identifier ([]) to the relationship names and merges the list with the column name list
			// because the relationship_name is copied over to $columnNames as relationship_name[] during initialization
			// we have to do add the suffix and then merge the columns since these columns do not exist in the actual table schema
			
			$relationshipCopyList = array_fill_keys(array_add_value_suffix(array_keys($this->relationships), $this->relationshipIdentifier), 'relationship');
			
			foreach(array_merge($relationshipCopyList, $page->table_columns) as $columnName => $columnInfo) {
				// Be nice and don't cause errors trying to copy over data to columns that don't exist
				if(!isset($columnNames[$columnName])) continue;

				if($columnNames[$columnName]['type'] == 'file') {
					// use uploaded file name rather than the original file name
					
					if(isset($form->$columnName->data['file_name'])) { // this is for when the file name isn't required
						$page->$columnName = $form->$columnName->data['file_name'];
					} else {
						Kohana::log('debug', 'File data not submitted');
					}
				} else if(substr($columnName, -2) == $this->relationshipIdentifier) {
					// multiple values isn't really natively supported in formo
					// we have to go directly into the post data and retrieve the list
					
					$normalizedRelationshipName = substr($columnName, 0, -2);
					$post = $this->input->post();
					$page->$normalizedRelationshipName = $post[$normalizedRelationshipName];
				} else {
					$page->$columnName = $form->$columnName->value;
				}
			}
			
			// if the form is valid, we return the $mode and the $page content
			// note that for the data to be saved $page->save() must be called afterward
			
			// you can use Crud as an ad hoc form generator
			// simple set your form content to $result['data] & specify a custom $edit_template
			
			return array('mode' => $mode, 'data' => $page);
		}
		
		$compiledForm = $form->get(TRUE);
		
		$this->form = $form;

		return array(
			'mode' => 'view',
			'data' => View::factory($this->edit_template, array_merge($this->base_config, array(
				'form' => $compiledForm,	// for the open/close form tags
				'fields' => View::factory($this->fields_template, array(
					'columns' => $columnNames,
					'form' => $compiledForm
				)),
				'errors' => array_merge($form->get_errors(), $this->errors),
				'submit_title' => empty($this->base_config['submit_title']) ? ($mode == "edit" ? 'Save Changes' : 'Create New '.$this->base_config['title']) : $this->base_config['submit_title']	// you overide this title by accessing $this->template->content->submit_title in the subclass
			)))
		);
    }
	
	public function delete($id = null) {
		$post = ORM::factory($this->orm_name, (int) $id);

		if(!$post->loaded) return false;
		
		// maybe do some more error checking here
		$post->delete();
		
		return true;
	}
}

?>